/***************************************************************************/
/*                                                                         */
/* Project   :        sim1750 -- Mil-Std-1750 Software Simulator           */
/*                                                                         */
/* Component :     arith.c -- simulate 1750A arithmetic operations         */
/*                                                                         */
/* Copyright :         (C) Daimler-Benz Aerospace AG, 1994-97              */
/*                                                                         */
/* Author    :      Oliver M. Kellogg, Dornier Satellite Systems,          */
/*                     Dept. RST13, D-81663 Munich, Germany.               */
/* Contact   :           oliver.kellogg@space.otn.dasa.de                  */
/*                                                                         */
/* Disclaimer:                                                             */
/*                                                                         */
/*  This program is free software; you can redistribute it and/or modify   */
/*  it under the terms of the GNU General Public License as published by   */
/*  the Free Software Foundation; either version 2 of the License, or      */
/*  (at your option) any later version.                                    */
/*                                                                         */
/*  This program is distributed in the hope that it will be useful,        */
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of         */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
/*  GNU General Public License for more details.                           */
/*                                                                         */
/*  You should have received a copy of the GNU General Public License      */
/*  along with this program; if not, write to the Free Software            */
/*  Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   */
/*                                                                         */
/***************************************************************************/

#include "arch.h"
#include "status.h"
#include "utils.h"
#include "fltcnv.h"

#define SMALLEST_FLOAT 1.0e-40

#define MIN_INT  -32768
#define MAX_INT   32767
#define MIN_LONG -0x80000000
#define MAX_LONG  0x7FFFFFFF

/************* utilities for Condition Status in the Status Word *************/

void
update_cs (short *operand, datatype data_type)
{
  bool is_zero;
  ushort sw_save = simreg.sw & 0x0fff;

  switch (data_type)
    {
    case VAR_INT:
      is_zero = (operand[0] == 0);
      break;
    case VAR_LONG:
    case VAR_FLOAT:
      is_zero = (operand[0] == 0 && operand[1] == 0);
      break;
    case VAR_DOUBLE:
      is_zero = (operand[0] == 0 && operand[1] == 0 && operand[2] == 0);
      break;
    }
  if (is_zero)
    simreg.sw = sw_save | CS_ZERO;
  else if (*operand & 0x8000)  /* Check sign bit. Same for all data types. */
    simreg.sw = sw_save | CS_NEGATIVE;
  else
    simreg.sw = sw_save | CS_POSITIVE;
}


void
compare (datatype data_type, short *operand0, short *operand1)
{
  ushort sw_save = simreg.sw & 0x0fff;
  short op0, op1;
  long lop0, lop1;
  double fop0, fop1;

  switch (data_type)
    {
    case VAR_INT:
      op0 = operand0[0];
      op1 = operand1[0];
      if (op0 < op1)
	simreg.sw = sw_save | CS_NEGATIVE;
      else if (op0 > op1)
	simreg.sw = sw_save | CS_POSITIVE;
      else
	simreg.sw = sw_save | CS_ZERO;
      break;
    case VAR_LONG:
      lop0 = ((long) operand0[0] << 16) | ((long) operand0[1] & 0xFFFFL);
      lop1 = ((long) operand1[0] << 16) | ((long) operand1[1] & 0xFFFFL);
      if (lop0 < lop1)
	simreg.sw = sw_save | CS_NEGATIVE;
      else if (lop0 > lop1)
	simreg.sw = sw_save | CS_POSITIVE;
      else
	simreg.sw = sw_save | CS_ZERO;
      break;
    case VAR_FLOAT:
      fop0 = from_1750flt (operand0);
      fop1 = from_1750flt (operand1);
      if (fop0 < fop1)
	simreg.sw = sw_save | CS_NEGATIVE;
      else if (fop0 > fop1)
	simreg.sw = sw_save | CS_POSITIVE;
      else
	simreg.sw = sw_save | CS_ZERO;
      break;
    case VAR_DOUBLE:
      fop0 = from_1750eflt (operand0);
      fop1 = from_1750eflt (operand1);
      if (fop0 < fop1)
	simreg.sw = sw_save | CS_NEGATIVE;
      else if (fop0 > fop1)
	simreg.sw = sw_save | CS_POSITIVE;
      else
	simreg.sw = sw_save | CS_ZERO;
      break;
    }
}


/*****************************************************************************/

/* See enum operation_kind in file arch.h :   */
static char *operation_name[] = { "ADD", "SUB", "MULS", "MUL", "DIVV", "DIV" };

/* add,subtract,multiply,divide -- for all 1750A data types.
   operand0 and operand1 are the input operands (vectors of shorts).
   The `vartyp' argument determines how the input vectors are interpreted.
   The result is stored in operand0.
   The condition code bits (CPZN) in simreg.sw are updated accordingly.
   The Pending Interrupt Register (simreg.pir) is also updated in case of
   under/overflow conditions during computation.
 */

void
arith (operation_kind operation,
       datatype vartyp,    /* Always specify data type of SECOND operand! */
       short *operand0, short *operand1)
{
  bool   ari_interrupt = FALSE;
  int    stat, opsign;
  long   laccu, lop0, lop1, rem;
  double faccu, fop0, fop1;

  switch (vartyp)
    {
    case VAR_INT:
      lop0 = (long) *operand0;
      lop1 = (long) *operand1;
      switch (operation)
	{		/* Nice and easy! Just use a larger data type. */
	case ARI_ADD:
	  laccu = lop0 + lop1;
	elsecase ARI_SUB:
	  laccu = lop0 - lop1;
	elsecase ARI_MUL:
	  laccu = lop0 * lop1;
	elsecase ARI_MULS:
	  laccu = lop0 * lop1;
	elsecase ARI_DIV:	/* falls through to following case! */
	  lop0 = ((long) operand0[0] << 16) | ((long) operand0[1] & 0xffff);
	case ARI_DIVV:
	  if (lop1 == 0)
	    ari_interrupt = TRUE;
	  else
	    {
	      laccu = lop0 / lop1;
	      rem = lop0 % lop1;
	    }
	}
      if (operation == ARI_MUL)
	{
	  operand0[0] = (short) ((laccu >> 16) & 0xffff);
	  operand0[1] = (short) (laccu & 0xffff);
	  update_cs (operand0, VAR_LONG);
	}
      else
	{
	  operand0[0] = (short) laccu;
	  if (operation == ARI_DIV || operation == ARI_DIVV)
	    operand0[1] = (short) rem;
	  if (ari_interrupt || (laccu < MIN_INT || laccu > MAX_INT))
	    {
	      simreg.sw |= CS_CARRY;
	      simreg.pir |= INTR_FIXOFL;
	      info ("FIXOFL on %s, op0=%ld op1=%ld res=%ld\n",
		    operation_name[operation], lop0, lop1, laccu);
	    }
          else
	    simreg.sw &= ~CS_CARRY;
	  update_cs (operand0, VAR_INT);
	}
      break;

    case VAR_LONG:
#ifdef LONGLONG
#define MAX_LLONG  0x7FFFFFFFLL
#define MIN_LLONG -0x80000000LL
      {		/* Nice and easy! Just use a larger data type. */
	long long llop0, llop1, llaccu;

	llop0 = ((long long) operand0[0] << 16)
	      | ((long long) operand0[1] & 0xFFFFLL);
	llop1 = ((long long) operand1[0] << 16)
	      | ((long long) operand1[1] & 0xFFFFLL);
	switch (operation)
	  {
	  case     ARI_ADD:
	    llaccu = llop0 + llop1;
	  elsecase ARI_SUB:
	    llaccu = llop0 - llop1;
	  elsecase ARI_MUL:
	    llaccu = llop0 * llop1;
	  elsecase ARI_DIV:
	    if (llop1 == 0)
	      ari_interrupt = TRUE;
	    else
	      llaccu = llop0 / llop1;
	    break;
	  default:
	    problem ("illegal operation code supplied to arith(VAR_LONG)");
	  }
	operand0[0] = (short) (llaccu >> 16);
	operand0[1] = (short) (llaccu & 0xffff);
	if (ari_interrupt || llaccu < MIN_LLONG || llaccu > MAX_LLONG)
	  {
	    simreg.sw |= CS_CARRY;
	    simreg.pir |= INTR_FIXOFL;
	    info
	   ("FIXOFL on long %s, op0=0x%lX%08lX op1=0x%lX%08lX res=0x%lX%08lX\n",
		operation_name[operation],
	        (long) (llop0 >> 32), (long) llop0,
	        (long) (llop1 >> 32), (long) llop1,
		(long)(llaccu >> 32), (long) llaccu);
	  }
	else
	  simreg.sw &= ~CS_CARRY;
	update_cs (operand0, VAR_LONG);
	break;
      }
#else
      /* Not so nice and easy if we don't have a larger data type. */
      lop0 = ((long) operand0[0] << 16) | ((long) operand0[1] & 0xFFFF);
      lop1 = ((long) operand1[0] << 16) | ((long) operand1[1] & 0xFFFF);
      if (operation == ARI_ADD ? opsign = 1 :
	  operation == ARI_SUB ? opsign = -1 : 0)
	{
	  if (lop0 > 0)		/* check for positive overflow */
	    {
	      if ((opsign == 1 && lop1 > 0 || opsign == -1 && lop1 < 0)
		  && opsign * lop1 > MAX_LONG - lop0)
		ari_interrupt = TRUE;
	    }
	  else			/* check for negative overflow */
	    {
	      if ((opsign == 1 && lop1 < 0 || opsign == -1 && lop1 > 0)
		  && opsign * lop1 < MIN_LONG - lop0)
		ari_interrupt = TRUE;
	    }
	  if (!ari_interrupt)	/* normal condition */
	    laccu = (operation == ARI_ADD) ? lop0 + lop1 : lop0 - lop1;
	}
      else
	/* MUL or DIV */
	{
	  if (lop0 == 0 || lop1 == 0)
	    {
	      if (lop1 == 0 && operation == ARI_DIV)
		ari_interrupt = TRUE;
	      else
		laccu = 0;
	    }
	  else if (operation == ARI_MUL)
	    {			/* (integer division doesn't need any checks) */
	      if (lop0 < 0 && lop1 < 0)		/* check for pos. overflow */
		{
		  if (lop0 < MAX_LONG / lop1)
		    ari_interrupt = TRUE;
		}
	      else if (lop0 > 0 && lop1 > 0)
		{
		  if (lop0 > MAX_LONG / lop1)
		    ari_interrupt = TRUE;
		}
	      else if (lop0 < 0 && lop1 > 0)	/* check for neg. overflow */
		{
		  if (lop0 < MIN_LONG / lop1)
		    ari_interrupt = TRUE;
		}
	      else if (lop0 > 0 && lop1 < 0)
		{
		  if (lop0 > MIN_LONG / -lop1)
		    ari_interrupt = TRUE;
		}
	      if (!ari_interrupt)
		laccu = lop0 * lop1;
	    }
	  else
	    laccu = lop0 / lop1;
	  if (ari_interrupt)
	    {
	      simreg.sw |= CS_CARRY;
	      simreg.pir |= INTR_FIXOFL;
	      info ("FIXOFL on long %s,  op0=%ld op1=%ld res=%ld\n",
			operation_name[operation], lop0, lop1, laccu);
	    }
	  else
	    simreg.sw &= ~CS_CARRY;
	}
      operand0[0] = (short) (laccu >> 16);
      operand0[1] = (short) (laccu & 0xffff);
      update_cs (operand0, VAR_LONG);
      break;
#endif

    case VAR_FLOAT:
    case VAR_DOUBLE:
      if (vartyp == VAR_FLOAT)
	{
	  fop0 = from_1750flt (operand0);
	  fop1 = from_1750flt (operand1);
	}
      else
	{
	  fop0 = from_1750eflt (operand0);
	  fop1 = from_1750eflt (operand1);
	}
      switch (operation)
	{
	case ARI_ADD:
	  faccu = fop0 + fop1;
	elsecase ARI_SUB:
	  faccu = fop0 - fop1;
	elsecase ARI_MUL:
	  faccu = fop0 * fop1;
	elsecase ARI_DIV:
	  if (fop1 >= -SMALLEST_FLOAT && fop1 <= SMALLEST_FLOAT)
	    {
	      simreg.pir |= INTR_FLTOFL;
	      operand0[0] = 0x0000;
	      operand0[1] = 0x0000;
	      if (vartyp == VAR_DOUBLE)
		operand0[2] = 0x0000;
	      ari_interrupt = TRUE;
	      info ("arith: divide by zero FLTOFL,  op0=%g op1=%g\n",
		    fop0, fop1);
	    }
	  else
	    faccu = fop0 / fop1;
	  break;
	default:
	  problem ("illegal operation code supplied to arith(VAR_FLOAT/DOUBLE)");
	}
      if (!ari_interrupt && (stat = (vartyp == VAR_FLOAT) ?
	      to_1750flt (faccu, operand0) : to_1750eflt (faccu, operand0)))
	{
	  if (stat > 0)
	    {
	      simreg.pir |= INTR_FLTOFL;
	      operand0[0] = 0x7FFF;
	      operand0[1] = 0xFF00;
	      if (vartyp == VAR_DOUBLE)
		operand0[2] = 0xFFFF;
	    }
	  else
	    {
	      simreg.pir |= INTR_FLTUFL;
	      operand0[0] = 0x8000;
	      operand0[1] = 0x0000;
	      if (vartyp == VAR_DOUBLE)
		    operand0[2] = 0x0000;
	    }
	  info ("arith: FLT%cFL during %s,  op0=%g op1=%g res=%g\n",
		(stat > 0 ? 'O' : 'U'),
		operation_name[(int) operation], fop0, fop1, faccu);
	}
      update_cs (operand0, vartyp);
    }
}


***************
*** 144,549 ****
         short *operand0, short *operand1)
  {
    int    stat, opsign;
! 
!   simreg.sw &= ~CS_CARRY;
  
    switch (vartyp)
      {
      case VAR_INT:
        switch (operation)
!         {                /* Nice and easy! Just use a larger data type. */
!         case ARI_ADD:
!           {
!             unsigned long lop0 = *(unsigned short *)operand0;
!             unsigned long lop1 = *(unsigned short *)operand1;
!             unsigned long laccu;
! 
!             laccu = lop0 + lop1;
! 
!             if (laccu & 0x10000)
!               simreg.sw |= CS_CARRY;
! 
!             if ((lop0 & 0x8000) == (lop1 & 0x8000) &&     
!                 (lop1 & 0x8000) != (laccu & 0x8000))
!               {
!                 simreg.pir |= INTR_FIXOFL;
!                 info ("FIXOFL on ADD, op0=%ld op1=%ld res=%ld\n",
!                     lop0, lop1, laccu);
!               }
! 
!             operand0 [0] = (unsigned short) laccu;
!             update_cs (operand0, VAR_INT);
!           }
! 
!         elsecase ARI_SUB:
!           {
!             unsigned long lop0 = *(unsigned short *)operand0;
!             unsigned long lop1 = *(unsigned short *)operand1;
!             unsigned long laccu;
! 
!             laccu = lop0 - lop1;
! 
!             if (laccu & 0x10000)
!               simreg.sw |= CS_CARRY;
! 
!             if ((lop0 & 0x8000) != (lop1 & 0x8000) &&     
!                 (lop0 & 0x8000) != (laccu & 0x8000))
!               {
!                 simreg.pir |= INTR_FIXOFL;
!                 info ("FIXOFL on SUB, op0=%ld op1=%ld res=%ld\n",
!                     lop0, lop1, laccu);
!               }
! 
!             operand0 [0] = (unsigned short) laccu;
!             update_cs (operand0, VAR_INT);
!           }
! 
!         elsecase ARI_MUL:
!           {
!             /* Single precision integer multiply with 32-bit result */
!             long lop0 = (long) *operand0;
!             long lop1 = (long) *operand1;
!             long laccu;
! 
!             laccu = lop0 * lop1;
! 
!             operand0 [0] = (unsigned short) ((laccu >> 16) & 0xffff);
!             operand0 [1] = (unsigned short) (laccu & 0xffff);
!             update_cs (operand0, VAR_LONG);
!           }
! 
!         elsecase ARI_MULS:
!           {
!             long lop0 = (long) *operand0;
!             long lop1 = (long) *operand1;
!             long laccu;
!             int overflow = 0;
! 
!             laccu = lop0 * lop1;
! 
!             if (lop0 != 0 && lop1 != 0)
!               {
!                 if ((lop0 & 0x8000) == (lop1 & 0x8000))
!                   {
!                     if ((laccu & 0xffff8000) != 0)
!                       overflow = 1;
!                   }
!                 else
!                   {
!                     if ((laccu & 0xffff8000) != 0xffff8000)
!                       overflow = 1;
!                   }
!               }
! 
!             if (overflow)
!               {
!                 simreg.pir |= INTR_FIXOFL;
!                 info ("FIXOFL on MULS, op0=%ld op1=%ld res=%ld\n",
!                     lop0, lop1, laccu);
!               }
! 
!             operand0 [0] = (short)laccu;
!             update_cs (operand0, VAR_INT);
!           }
! 
!         elsecase ARI_DIV:
!           {
!             /* 16 bit divide with 32-bit dividend */
!             long lop0 = ((long) operand0[0] << 16) | ((long) operand0[1] & 0xffff);
!             long lop1 = (long) *operand1;
!             long laccu;
!             long rem;
! 
!             if (lop1 != 0)
!               {
!                 laccu = lop0 / lop1;
!                 rem = lop0 % lop1;
!               }
! 
!             if (lop1 == 0 ||
!                 (lop0 == 0x8000 && lop1 == 0xffff))
!               {
!                 simreg.pir |= INTR_FIXOFL;
!                 info ("FIXOFL on DIV, op0=%ld op1=%ld res=%ld\n",
!                     lop0, lop1, laccu);
!               }
! 
!             operand0 [0] = (short)laccu;
!             update_cs (operand0, VAR_INT);
!           }
! 
!         elsecase ARI_DIVV:
!           {
!             /* 16 bit signed divide with 16-bit dividend */
!             long lop0 = (long) *operand0;
!             long lop1 = (long) *operand1;
!             long laccu;
!             long rem;
! 
!             if (lop1 != 0)
!               {
!                 laccu = lop0 / lop1;
!                 rem = lop0 % lop1;
!               }
! 
!             if (lop1 == 0 ||
!                 (lop0 == 0x8000 && lop1 == 0xffff))
!               {
!                 simreg.pir |= INTR_FIXOFL;
!                 info ("FIXOFL on DIVV, op0=%ld op1=%ld res=%ld\n",
!                     lop0, lop1, laccu);
!               }
! 
!             operand0 [0] = (short)laccu;
!             operand0 [1] = (short)rem;
!             update_cs (operand0, VAR_INT);
!           }
!         }
        break;
  
      case VAR_LONG:
!       switch (operation)
!         {                /* Nice and easy! Just use a larger data type. */
!         case ARI_ADD:
!           {
!             unsigned op00 = operand0[0];
!             unsigned op01 = operand0[1];
!             unsigned op10 = operand1[0];
!             unsigned op11 = operand1[1];
! 
!             unsigned long long lop0 = (op00 << 16) | (op01 & 0xffff);
!             unsigned long long lop1 = (op10 << 16) | (op11 & 0xffff);
! 
!             unsigned long long llaccu;
! 
!             llaccu = lop0 + lop1;
! 
!             if (llaccu & 0x100000000LL)
!               simreg.sw |= CS_CARRY;
! 
!             if ((lop0 & 0x80000000LL) == (lop1 & 0x80000000LL) &&     
!                 (lop1 & 0x80000000LL) != (llaccu & 0x80000000LL))
!               {
!                 simreg.pir |= INTR_FIXOFL;
!                 info ("FIXOFL on long ADD, op0=%lld op1=%lld res=%lld\n",
!                     lop0, lop1, llaccu);
!               }
! 
!             operand0 [0] = (short) (llaccu >> 16);
!             operand0 [1] = (short) (llaccu & 0xffff);
!             update_cs (operand0, VAR_LONG);
!           }
! 
!         elsecase ARI_SUB:
!           {
!             unsigned op00 = operand0[0];
!             unsigned op01 = operand0[1];
!             unsigned op10 = operand1[0];
!             unsigned op11 = operand1[1];
! 
!             unsigned long long lop0 = (op00 << 16) | (op01 & 0xffff);
!             unsigned long long lop1 = (op10 << 16) | (op11 & 0xffff);
! 
!             unsigned long long llaccu;
! 
!             llaccu = lop0 - lop1;
! 
!             if (llaccu & 0x100000000LL)
!               simreg.sw |= CS_CARRY;
! 
!             if ((lop0 & 0x80000000LL) != (lop1 & 0x80000000LL) &&     
!                 (lop0 & 0x80000000LL) != (llaccu & 0x80000000LL))
!               {
!                 simreg.pir |= INTR_FIXOFL;
!                 info ("FIXOFL on long SUB, op0=%lld op1=%lld res=%lld\n",
!                     lop0, lop1, llaccu);
!               }
! 
!             operand0 [0] = (short) (llaccu >> 16);
!             operand0 [1] = (short) (llaccu & 0xffff);
!             update_cs (operand0, VAR_LONG);
!           }
! 
!         elsecase ARI_MUL:
!           {
!             /* Double precision integer multiply with ??-bit result */
!             long long lop0 = ((long long) operand0[0] << 16)
!                     | ((long long) operand0[1] & 0xFFFFLL);
!             long long lop1 = ((long long) operand1[0] << 16)
!                     | ((long long) operand1[1] & 0xFFFFLL);
!             long long llaccu;
! 
!             llaccu = lop0 * lop1;
! 
!             operand0 [0] = (short) (llaccu >> 16);
!             operand0 [1] = (short) (llaccu & 0xffff);
!             update_cs (operand0, VAR_LONG);
!           }
! 
!         elsecase ARI_DIV:
!           {
!             /* 32 bit divide with 32-bit dividend */
!             long long lop0 = ((long long) operand0[0] << 16)
!                     | ((long long) operand0[1] & 0xFFFFLL);
!             long long lop1 = ((long long) operand1[0] << 16)
!                     | ((long long) operand1[1] & 0xFFFFLL);
!             long llaccu;
!             long rem;
! 
!             if (lop1 != 0)
!               {
!                 llaccu = lop0 / lop1;
!                 rem = lop0 % lop1;
!               }
! 
!             if (rem < 0 && lop0 >= 0)
!               llaccu--;
!             else if (rem > 0 && lop0 < 0)
!               llaccu++;
!     
!             if (lop1 == 0 ||
!                 (lop0 == 0x80000000 && lop1 == 0xffffffff))
!               {
!                 simreg.pir |= INTR_FIXOFL;
!                 info ("FIXOFL on long DIV, op0=%ld op1=%ld res=%ld\n",
!                     lop0, lop1, llaccu);
!               }
! 
!             operand0 [0] = (short) (llaccu >> 16);
!             operand0 [1] = (short) (llaccu & 0xffff);
!             update_cs (operand0, VAR_LONG);
!           }
! 
!         }
!       break;
! 
!     case VAR_FLOAT:
!       {
!         int overflow = 0;
!         const double fop0 = from_1750flt (operand0);
!         const double fop1 = from_1750flt (operand1);
!         double faccu;
! 
!         switch (operation)
!           {
!           case ARI_ADD:
!             faccu = fop0 + fop1;
!           elsecase ARI_SUB:
!             faccu = fop0 - fop1;
!           elsecase ARI_MUL:
!             faccu = fop0 * fop1;
!           elsecase ARI_DIV:
!             if ((fop1 < 0.0 && -fop1 < FLT_1750_MIN) ||
!                 (fop1 >= 0.0 && fop1 < FLT_1750_MIN))
!               {
!                 overflow = 1;
!               }
!             else
!               faccu = fop0 / fop1;
!             break;
!           default:
!             problem ("illegal operation code supplied to arith VAR_FLOAT");
!           }
! 
!         if (overflow)
!           {
!             simreg.pir |= INTR_FLTOFL;
!             operand0[0] = 0x0000;
!             operand0[1] = 0x0000;
! 
!             info ("arith: FLT zero divide during %s,  op0=%g op1=%g res=%g\n",
!                   operation_name[(int) operation], fop0, fop1, faccu);
!           }
!         else 
!           {
!             int stat = to_1750flt (faccu, operand0);
! 
!             if (stat > 0)
!               {
!                 simreg.pir |= INTR_FLTOFL;
!                 operand0[0] = 0x7FFF;
!                 operand0[1] = 0xFF7F;
!               }
!             else if (stat < 0)
!               {
!                 simreg.pir |= INTR_FLTUFL;
!                 operand0[0] = 0x4000;
!                 operand0[1] = 0x0080;
!               }
! 
!             if (stat != 0)
!               info ("arith: FLT%cFL during %s,  op0=%g op1=%g res=%g\n",
!                     (stat > 0 ? 'O' : 'U'),
!                     operation_name[(int) operation], fop0, fop1, faccu);
!           }
        }
        break;
  
      case VAR_DOUBLE:
!       {
!         int overflow = 0;
!         const double fop0 = from_1750eflt (operand0);
!         const double fop1 = from_1750eflt (operand1);
!         double faccu;
! 
!         switch (operation)
!           {
!           case ARI_ADD:
!             faccu = fop0 + fop1;
!           elsecase ARI_SUB:
!             faccu = fop0 - fop1;
!           elsecase ARI_MUL:
!             faccu = fop0 * fop1;
!           elsecase ARI_DIV:
!             if ((fop1 < 0.0 && -fop1 < DBL_1750_MIN) ||
!                 (fop1 >= 0.0 && fop1 < DBL_1750_MIN))
!               overflow = 1;
!             else
!               faccu = fop0 / fop1;
!             break;
!           default:
!             problem ("illegal operation code supplied to arith VAR_DOUBLE");
!           }
! 
!         if (overflow)
!           {
!             simreg.pir |= INTR_FLTOFL;
!             operand0[0] = 0x0000;
!             operand0[1] = 0x0000;
!             operand0[2] = 0x0000;
! 
!             info ("arith: FLT zero divide during %s,  op0=%g op1=%g res=%g\n",
!                   operation_name[(int) operation], fop0, fop1, faccu);
!           }
!         else 
!           {
!             int stat = to_1750eflt (faccu, operand0);
! 
!             if (stat > 0)
!               {
!                 simreg.pir |= INTR_FLTOFL;
!                 operand0[0] = 0x7FFF;
!                 operand0[1] = 0xFF7F;
!                 operand0[2] = 0xFFFF;
!               }
!             else if (stat < 0)
!               {
!                 simreg.pir |= INTR_FLTUFL;
!                 //operand0[0] = 0x4000;
!                 //operand0[1] = 0x0080;
!                 //operand0[2] = 0x0000;
!                 operand0[0] = 0x0000;
!                 operand0[1] = 0x0000;
!                 operand0[2] = 0x0000;
!               }
! 
!             if (stat != 0)
!               info ("arith: FLT%cFL during %s,  op0=%g op1=%g res=%g\n",
!                     (stat > 0 ? 'O' : 'U'),
!                     operation_name[(int) operation], fop0, fop1, faccu);
!           }
!       }
!   }
! 
  }


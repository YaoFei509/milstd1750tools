/***************************************************************************/
/*                                                                         */
/* Project   :        sim1750 -- Mil-Std-1750 Software Simulator           */
/*                                                                         */
/* Component :     arith.c -- simulate 1750A arithmetic operations         */
/*                                                                         */
/* Copyright :         (C) Daimler-Benz Aerospace AG, 1989-96              */
/*                                                                         */
/* Author    :      Oliver M. Kellogg, Dornier Satellite Systems,          */
/*                     Dept. RST13, D-81663 Munich, Germany.               */
/* Contact   :           oliver.kellogg@space.otn.dasa.de                  */
/*                                                                         */
/* Disclaimer:                                                             */
/*                                                                         */
/*  This program is free software; you can redistribute it and/or modify   */
/*  it under the terms of the GNU General Public License as published by   */
/*  the Free Software Foundation; either version 2 of the License, or      */
/*  (at your option) any later version.                                    */
/*                                                                         */
/*  This program is distributed in the hope that it will be useful,        */
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of         */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
/*  GNU General Public License for more details.                           */
/*                                                                         */
/*  You should have received a copy of the GNU General Public License      */
/*  along with this program; if not, write to the Free Software            */
/*  Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   */
/*                                                                         */
/***************************************************************************/

#include "arch.h"
#include "status.h"
#include "utils.h"
#include "flt1750.h"

#define FLT_1750_EPSILON     1.1920928955078125000E-7
#define FLT_1750_MAX         1.70141163178059628080016879768632819712E38
#define FLT_1750_MIN 1.4693679385278593849609206715278070972733319459651094E-39

#define DBL_1750_EPSILON     1.818989403545856475830078125000E-12
#define DBL_1750_MAX         1.70141183460159746721865958647159324672E38
#define DBL_1750_MIN 1.4693679385278593849609206715278070972733319459651094E-39


/************* utilities for Condition Status in the Status Word *************/

void
update_cs (short *operand, datatype data_type)
{
  bool is_zero;
  ushort sw_save = simreg.sw & 0x8fff;

  switch (data_type)
    {
    case VAR_INT:
      is_zero = (operand[0] == 0);
      break;
    case VAR_LONG:
    case VAR_FLOAT:
      is_zero = (operand[0] == 0 && operand[1] == 0);
      break;
    case VAR_DOUBLE:
      is_zero = (operand[0] == 0 && operand[1] == 0 && operand[2] == 0);
      break;
    }
  if (is_zero)
    simreg.sw = sw_save | CS_ZERO;
  else if (*operand & 0x8000)  /* Check sign bit. Same for all data types. */
    simreg.sw = sw_save | CS_NEGATIVE;
  else
    simreg.sw = sw_save | CS_POSITIVE;
}


void
compare (datatype data_type, short *operand0, short *operand1)
{
  ushort sw_save = simreg.sw & 0x0fff;
  short op0, op1;
  long lop0, lop1;
  double fop0, fop1;

  switch (data_type)
    {
    case VAR_INT:
      op0 = operand0[0];
      op1 = operand1[0];
      if (op0 < op1)
        simreg.sw = sw_save | CS_NEGATIVE;
      else if (op0 > op1)
        simreg.sw = sw_save | CS_POSITIVE;
      else
        simreg.sw = sw_save | CS_ZERO;
      break;
    case VAR_LONG:
      lop0 = ((long) operand0[0] << 16) | ((long) operand0[1] & 0xFFFFL);
      lop1 = ((long) operand1[0] << 16) | ((long) operand1[1] & 0xFFFFL);
      if (lop0 < lop1)
        simreg.sw = sw_save | CS_NEGATIVE;
      else if (lop0 > lop1)
        simreg.sw = sw_save | CS_POSITIVE;
      else
        simreg.sw = sw_save | CS_ZERO;
      break;
    case VAR_FLOAT:
      fop0 = from_1750flt (operand0);
      fop1 = from_1750flt (operand1);
      if (fop0 < fop1)
        simreg.sw = sw_save | CS_NEGATIVE;
      else if (fop0 > fop1)
        simreg.sw = sw_save | CS_POSITIVE;
      else
        simreg.sw = sw_save | CS_ZERO;
      break;
    case VAR_DOUBLE:
      fop0 = from_1750eflt (operand0);
      fop1 = from_1750eflt (operand1);
      if (fop0 < fop1)
        simreg.sw = sw_save | CS_NEGATIVE;
      else if (fop0 > fop1)
        simreg.sw = sw_save | CS_POSITIVE;
      else
        simreg.sw = sw_save | CS_ZERO;
      break;
    }
}


/*****************************************************************************/

/* See enum operation_kind in file arch.h :   */
static char *operation_name[] = { "ADD", "SUB", "MULS", "MUL", "DIVV", "DIV" };

/* add,subtract,multiply,divide -- for all 1750A data types.
   operand0 and operand1 are the input operands (vectors of shorts).
   The `vartyp' argument determines how the input vectors are interpreted.
   The result is stored in operand0.
   The condition code bits (CPZN) in simreg.sw are updated accordingly.
   The Pending Interrupt Register (simreg.pir) is also updated in case of
   under/overflow conditions during computation.
 */

void
arith (operation_kind operation,
       datatype vartyp,    /* Always specify data type of SECOND operand! */
       short *operand0, short *operand1)
{
  int    stat, opsign;

  simreg.sw &= ~CS_CARRY;

  switch (vartyp)
    {
    case VAR_INT:
      switch (operation)
        {                /* Nice and easy! Just use a larger data type. */
        case ARI_ADD:
          {
            ulong lop0 = *(ushort *)operand0;
            ulong lop1 = *(ushort *)operand1;
            ulong laccu;

            laccu = lop0 + lop1;

            if (laccu & 0x10000)
              simreg.sw |= CS_CARRY;

            if ((lop0 & 0x8000) == (lop1 & 0x8000) &&     
                (lop1 & 0x8000) != (laccu & 0x8000))
              {
                simreg.pir |= INTR_FIXOFL;
                info ("FIXOFL on ADD, op0=%ld op1=%ld res=%ld\n",
                    lop0, lop1, laccu);
              }

            operand0 [0] = (ushort) laccu;
            update_cs (operand0, VAR_INT);
          }

        elsecase ARI_SUB:
          {
            ulong lop0 = *(ushort *)operand0;
            ulong lop1 = *(ushort *)operand1;
            ulong laccu;

            laccu = lop0 - lop1;

            if (laccu & 0x10000)
              simreg.sw |= CS_CARRY;

            if ((lop0 & 0x8000) != (lop1 & 0x8000) &&     
                (lop0 & 0x8000) != (laccu & 0x8000))
              {
                simreg.pir |= INTR_FIXOFL;
                info ("FIXOFL on SUB, op0=%ld op1=%ld res=%ld\n",
                    lop0, lop1, laccu);
              }

            operand0 [0] = (ushort) laccu;
            update_cs (operand0, VAR_INT);
          }

        elsecase ARI_MUL:
          {
            /* Single precision integer multiply with 32-bit result */
            long lop0 = (long) *operand0;
            long lop1 = (long) *operand1;
            long laccu;

            laccu = lop0 * lop1;

            operand0 [0] = (ushort) ((laccu >> 16) & 0xffff);
            operand0 [1] = (ushort) (laccu & 0xffff);
            update_cs (operand0, VAR_LONG);
          }

        elsecase ARI_MULS:
          {
            long lop0 = (long) *operand0;
            long lop1 = (long) *operand1;
            long laccu;
            int overflow = 0;

            laccu = lop0 * lop1;

            if (lop0 != 0 && lop1 != 0)
              {
                if ((lop0 & 0x8000) == (lop1 & 0x8000))
                  {
                    if ((laccu & 0xffff8000) != 0)
                      overflow = 1;
                  }
                else
                  {
                    if ((laccu & 0xffff8000) != 0xffff8000)
                      overflow = 1;
                  }
              }

            if (overflow)
              {
                simreg.pir |= INTR_FIXOFL;
                info ("FIXOFL on MULS, op0=%ld op1=%ld res=%ld\n",
                    lop0, lop1, laccu);
              }

            operand0 [0] = (short)laccu;
            update_cs (operand0, VAR_INT);
          }

        elsecase ARI_DIV:
          {
            /* 16 bit divide with 32-bit dividend */
            long lop0 = ((long) operand0[0] << 16) | ((long) operand0[1] & 0xffff);
            long lop1 = (long) *operand1;
            long laccu;
            long rem;

            laccu = lop0 / lop1;
            rem = lop0 % lop1;

            if (lop1 == 0 ||
                (lop0 == 0x8000 && lop1 == 0xffff))
              {
                simreg.pir |= INTR_FIXOFL;
                info ("FIXOFL on DIV, op0=%ld op1=%ld res=%ld\n",
                    lop0, lop1, laccu);
              }

            operand0 [0] = (short)laccu;
            update_cs (operand0, VAR_INT);
          }

        elsecase ARI_DIVV:
          {
            /* 16 bit signed divide with 16-bit dividend */
            long lop0 = (long) *operand0;
            long lop1 = (long) *operand1;
            long laccu;
            long rem;

            laccu = lop0 / lop1;
            rem = lop0 % lop1;

            if (lop1 == 0 ||
                (lop0 == 0x8000 && lop1 == 0xffff))
              {
                simreg.pir |= INTR_FIXOFL;
                info ("FIXOFL on DIVV, op0=%ld op1=%ld res=%ld\n",
                    lop0, lop1, laccu);
              }

            operand0 [0] = (short)laccu;
            operand0 [1] = (short)rem;
            update_cs (operand0, VAR_INT);
          }
        }
      break;

    case VAR_LONG:
      switch (operation)
        {                /* Nice and easy! Just use a larger data type. */
        case ARI_ADD:
          {
            ulong op00 = (ulong) operand0[0];
            ulong op01 = (ulong) operand0[1];
            ulong op10 = (ulong) operand1[0];
            ulong op11 = (ulong) operand1[1];

            unsigned long long lop0 = (op00 << 16) | (op01 & 0xffff);
            unsigned long long lop1 = (op10 << 16) | (op11 & 0xffff);

            unsigned long long llaccu;

            llaccu = lop0 + lop1;

            if (llaccu & 0x100000000LL)
              simreg.sw |= CS_CARRY;

            if ((lop0 & 0x80000000LL) == (lop1 & 0x80000000LL) &&     
                (lop1 & 0x80000000LL) != (llaccu & 0x80000000LL))
              {
                simreg.pir |= INTR_FIXOFL;
                info ("FIXOFL on long ADD, op0=%lld op1=%lld res=%lld\n",
                    lop0, lop1, llaccu);
              }

            operand0 [0] = (short) (llaccu >> 16);
            operand0 [1] = (short) (llaccu & 0xffff);
            update_cs (operand0, VAR_LONG);
          }

        elsecase ARI_SUB:
          {
            ulong op00 = (ulong) operand0[0];
            ulong op01 = (ulong) operand0[1];
            ulong op10 = (ulong) operand1[0];
            ulong op11 = (ulong) operand1[1];

            unsigned long long lop0 = (op00 << 16) | (op01 & 0xffff);
            unsigned long long lop1 = (op10 << 16) | (op11 & 0xffff);

            unsigned long long llaccu;

            llaccu = lop0 - lop1;

            if (llaccu & 0x100000000LL)
              simreg.sw |= CS_CARRY;

            if ((lop0 & 0x80000000LL) != (lop1 & 0x80000000LL) &&     
                (lop0 & 0x80000000LL) != (llaccu & 0x80000000LL))
              {
                simreg.pir |= INTR_FIXOFL;
                info ("FIXOFL on long SUB, op0=%lld op1=%lld res=%lld\n",
                    lop0, lop1, llaccu);
              }

            operand0 [0] = (short) (llaccu >> 16);
            operand0 [1] = (short) (llaccu & 0xffff);
            update_cs (operand0, VAR_LONG);
          }

        elsecase ARI_MUL:
          {
            /* Double precision integer multiply with ??-bit result */
            long long lop0 = ((long long) operand0[0] << 16)
                    | ((long long) operand0[1] & 0xFFFFLL);
            long long lop1 = ((long long) operand1[0] << 16)
                    | ((long long) operand1[1] & 0xFFFFLL);
            long long llaccu;

            llaccu = lop0 * lop1;

            operand0 [0] = (short) (llaccu >> 16);
            operand0 [1] = (short) (llaccu & 0xffff);
            update_cs (operand0, VAR_LONG);
          }

        elsecase ARI_DIV:
          {
            /* 32 bit divide with 32-bit dividend */
            long long lop0 = ((long long) operand0[0] << 16)
                    | ((long long) operand0[1] & 0xFFFFLL);
            long long lop1 = ((long long) operand1[0] << 16)
                    | ((long long) operand1[1] & 0xFFFFLL);
            long llaccu;
            long rem;

            llaccu = lop0 / lop1;
            rem = lop0 % lop1;

            if (rem < 0 && lop0 >= 0)
              llaccu--;
            else if (rem > 0 && lop0 < 0)
              llaccu++;
    
            if (lop1 == 0 ||
                (lop0 == 0x80000000 && lop1 == 0xffffffff))
              {
                simreg.pir |= INTR_FIXOFL;
                info ("FIXOFL on long DIV, op0=%ld op1=%ld res=%ld\n",
                    lop0, lop1, llaccu);
              }

            operand0 [0] = (short) (llaccu >> 16);
            operand0 [1] = (short) (llaccu & 0xffff);
            update_cs (operand0, VAR_LONG);
          }

        }
      break;

    case VAR_FLOAT:
      {
        int overflow = 0;
        const double fop0 = from_1750flt (operand0);
        const double fop1 = from_1750flt (operand1);
        double faccu;

        switch (operation)
          {
          case ARI_ADD:
            faccu = fop0 + fop1;
          elsecase ARI_SUB:
            faccu = fop0 - fop1;
          elsecase ARI_MUL:
            faccu = fop0 * fop1;
          elsecase ARI_DIV:
            if ((fop1 < 0.0 && -fop1 < FLT_1750_MIN) ||
                (fop1 >= 0.0 && fop1 < FLT_1750_MIN))
              {
                overflow = 1;
              }
            else
              faccu = fop0 / fop1;
            break;
          default:
            problem ("illegal operation code supplied to arith VAR_FLOAT");
          }

        if (overflow)
          {
            simreg.pir |= INTR_FLTOFL;
            operand0[0] = 0x0000;
            operand0[1] = 0x0000;

            info ("arith: FLT zero divide during %s,  op0=%g op1=%g res=%g\n",
                  operation_name[(int) operation], fop0, fop1, faccu);
          }
        else 
          {
            int stat = to_1750flt (faccu, operand0);

            if (stat > 0)
              {
                simreg.pir |= INTR_FLTOFL;
                operand0[0] = 0x7FFF;
                operand0[1] = 0xFF7F;
              }
            else if (stat < 0)
              {
                simreg.pir |= INTR_FLTUFL;
                operand0[0] = 0x4000;
                operand0[1] = 0x0080;
              }

            if (stat != 0)
              info ("arith: FLT%cFL during %s,  op0=%g op1=%g res=%g\n",
                    (stat > 0 ? 'O' : 'U'),
                    operation_name[(int) operation], fop0, fop1, faccu);
          }
      }

    case VAR_DOUBLE:
      {
        int overflow = 0;
        const double fop0 = from_1750eflt (operand0);
        const double fop1 = from_1750eflt (operand1);
        double faccu;

        switch (operation)
          {
          case ARI_ADD:
            faccu = fop0 + fop1;
          elsecase ARI_SUB:
            faccu = fop0 - fop1;
          elsecase ARI_MUL:
            faccu = fop0 * fop1;
          elsecase ARI_DIV:
            if ((fop1 < 0.0 && -fop1 < DBL_1750_MIN) ||
                (fop1 >= 0.0 && fop1 < DBL_1750_MIN))
              overflow = 1;
            else
              faccu = fop0 / fop1;
            break;
          default:
            problem ("illegal operation code supplied to arith VAR_DOUBLE");
          }

        if (overflow)
          {
            simreg.pir |= INTR_FLTOFL;
            operand0[0] = 0x0000;
            operand0[1] = 0x0000;
            operand0[2] = 0x0000;

            info ("arith: FLT zero divide during %s,  op0=%g op1=%g res=%g\n",
                  operation_name[(int) operation], fop0, fop1, faccu);
          }
        else 
          {
            int stat = to_1750eflt (faccu, operand0);

            if (stat > 0)
              {
                simreg.pir |= INTR_FLTOFL;
                operand0[0] = 0x7FFF;
                operand0[1] = 0xFF7F;
                operand0[2] = 0xFFFF;
              }
            else if (stat < 0)
              {
                simreg.pir |= INTR_FLTUFL;
                //operand0[0] = 0x4000;
                //operand0[1] = 0x0080;
                //operand0[2] = 0x0000;
                operand0[0] = 0x0000;
                operand0[1] = 0x0000;
                operand0[2] = 0x0000;
              }

            if (stat != 0)
              info ("arith: FLT%cFL during %s,  op0=%g op1=%g res=%g\n",
                    (stat > 0 ? 'O' : 'U'),
                    operation_name[(int) operation], fop0, fop1, faccu);
          }
      }
  }

}

